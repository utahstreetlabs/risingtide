#
# Autogenerated by Thrift Compiler (0.7.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#


module Storm
    module TopologyInitialStatus
      ACTIVE = 1
      INACTIVE = 2
      VALUE_MAP = {1 => "ACTIVE", 2 => "INACTIVE"}
      VALID_VALUES = Set.new([ACTIVE, INACTIVE]).freeze
    end

    class JavaObjectArg < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def int_arg(val)
          JavaObjectArg.new(:int_arg, val)
        end

        def long_arg(val)
          JavaObjectArg.new(:long_arg, val)
        end

        def string_arg(val)
          JavaObjectArg.new(:string_arg, val)
        end

        def bool_arg(val)
          JavaObjectArg.new(:bool_arg, val)
        end

        def binary_arg(val)
          JavaObjectArg.new(:binary_arg, val)
        end

        def double_arg(val)
          JavaObjectArg.new(:double_arg, val)
        end
      end

      INT_ARG = 1
      LONG_ARG = 2
      STRING_ARG = 3
      BOOL_ARG = 4
      BINARY_ARG = 5
      DOUBLE_ARG = 6

      FIELDS = {
        INT_ARG => {:type => ::Thrift::Types::I32, :name => 'int_arg'},
        LONG_ARG => {:type => ::Thrift::Types::I64, :name => 'long_arg'},
        STRING_ARG => {:type => ::Thrift::Types::STRING, :name => 'string_arg'},
        BOOL_ARG => {:type => ::Thrift::Types::BOOL, :name => 'bool_arg'},
        BINARY_ARG => {:type => ::Thrift::Types::STRING, :name => 'binary_arg', :binary => true},
        DOUBLE_ARG => {:type => ::Thrift::Types::DOUBLE, :name => 'double_arg'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class JavaObject
      include ::Thrift::Struct, ::Thrift::Struct_Union
      FULL_CLASS_NAME = 1
      ARGS_LIST = 2

      FIELDS = {
        FULL_CLASS_NAME => {:type => ::Thrift::Types::STRING, :name => 'full_class_name'},
        ARGS_LIST => {:type => ::Thrift::Types::LIST, :name => 'args_list', :element => {:type => ::Thrift::Types::STRUCT, :class => Storm::JavaObjectArg}}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field full_class_name is unset!') unless @full_class_name
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field args_list is unset!') unless @args_list
      end

      ::Thrift::Struct.generate_accessors self
    end

    class NullStruct
      include ::Thrift::Struct, ::Thrift::Struct_Union

      FIELDS = {

      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class GlobalStreamId
      include ::Thrift::Struct, ::Thrift::Struct_Union
      COMPONENTID = 1
      STREAMID = 2

      FIELDS = {
        COMPONENTID => {:type => ::Thrift::Types::STRING, :name => 'componentId'},
        STREAMID => {:type => ::Thrift::Types::STRING, :name => 'streamId'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field componentId is unset!') unless @componentId
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field streamId is unset!') unless @streamId
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Grouping < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def fields(val)
          Grouping.new(:fields, val)
        end

        def shuffle(val)
          Grouping.new(:shuffle, val)
        end

        def all(val)
          Grouping.new(:all, val)
        end

        def none(val)
          Grouping.new(:none, val)
        end

        def direct(val)
          Grouping.new(:direct, val)
        end

        def custom_object(val)
          Grouping.new(:custom_object, val)
        end

        def custom_serialized(val)
          Grouping.new(:custom_serialized, val)
        end

        def local_or_shuffle(val)
          Grouping.new(:local_or_shuffle, val)
        end
      end

      FIELDS = 1
      SHUFFLE = 2
      ALL = 3
      NONE = 4
      DIRECT = 5
      CUSTOM_OBJECT = 6
      CUSTOM_SERIALIZED = 7
      LOCAL_OR_SHUFFLE = 8

      FIELDS = {
        FIELDS => {:type => ::Thrift::Types::LIST, :name => 'fields', :element => {:type => ::Thrift::Types::STRING}},
        SHUFFLE => {:type => ::Thrift::Types::STRUCT, :name => 'shuffle', :class => Storm::NullStruct},
        ALL => {:type => ::Thrift::Types::STRUCT, :name => 'all', :class => Storm::NullStruct},
        NONE => {:type => ::Thrift::Types::STRUCT, :name => 'none', :class => Storm::NullStruct},
        DIRECT => {:type => ::Thrift::Types::STRUCT, :name => 'direct', :class => Storm::NullStruct},
        CUSTOM_OBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'custom_object', :class => Storm::JavaObject},
        CUSTOM_SERIALIZED => {:type => ::Thrift::Types::STRING, :name => 'custom_serialized', :binary => true},
        LOCAL_OR_SHUFFLE => {:type => ::Thrift::Types::STRUCT, :name => 'local_or_shuffle', :class => Storm::NullStruct}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class StreamInfo
      include ::Thrift::Struct, ::Thrift::Struct_Union
      OUTPUT_FIELDS = 1
      DIRECT = 2

      FIELDS = {
        OUTPUT_FIELDS => {:type => ::Thrift::Types::LIST, :name => 'output_fields', :element => {:type => ::Thrift::Types::STRING}},
        DIRECT => {:type => ::Thrift::Types::BOOL, :name => 'direct'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field output_fields is unset!') unless @output_fields
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field direct is unset!') if @direct.nil?
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ShellComponent
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EXECUTION_COMMAND = 1
      SCRIPT = 2

      FIELDS = {
        EXECUTION_COMMAND => {:type => ::Thrift::Types::STRING, :name => 'execution_command'},
        SCRIPT => {:type => ::Thrift::Types::STRING, :name => 'script'}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ComponentObject < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def serialized_java(val)
          ComponentObject.new(:serialized_java, val)
        end

        def shell(val)
          ComponentObject.new(:shell, val)
        end

        def java_object(val)
          ComponentObject.new(:java_object, val)
        end
      end

      SERIALIZED_JAVA = 1
      SHELL = 2
      JAVA_OBJECT = 3

      FIELDS = {
        SERIALIZED_JAVA => {:type => ::Thrift::Types::STRING, :name => 'serialized_java', :binary => true},
        SHELL => {:type => ::Thrift::Types::STRUCT, :name => 'shell', :class => Storm::ShellComponent},
        JAVA_OBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'java_object', :class => Storm::JavaObject}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class ComponentCommon
      include ::Thrift::Struct, ::Thrift::Struct_Union
      INPUTS = 1
      STREAMS = 2
      PARALLELISM_HINT = 3
      JSON_CONF = 4

      FIELDS = {
        INPUTS => {:type => ::Thrift::Types::MAP, :name => 'inputs', :key => {:type => ::Thrift::Types::STRUCT, :class => Storm::GlobalStreamId}, :value => {:type => ::Thrift::Types::STRUCT, :class => Storm::Grouping}},
        STREAMS => {:type => ::Thrift::Types::MAP, :name => 'streams', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => Storm::StreamInfo}},
        PARALLELISM_HINT => {:type => ::Thrift::Types::I32, :name => 'parallelism_hint', :optional => true},
        JSON_CONF => {:type => ::Thrift::Types::STRING, :name => 'json_conf', :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field inputs is unset!') unless @inputs
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field streams is unset!') unless @streams
      end

      ::Thrift::Struct.generate_accessors self
    end

    class SpoutSpec
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SPOUT_OBJECT = 1
      COMMON = 2

      FIELDS = {
        SPOUT_OBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'spout_object', :class => Storm::ComponentObject},
        COMMON => {:type => ::Thrift::Types::STRUCT, :name => 'common', :class => Storm::ComponentCommon}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field spout_object is unset!') unless @spout_object
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field common is unset!') unless @common
      end

      ::Thrift::Struct.generate_accessors self
    end

    class Bolt
      include ::Thrift::Struct, ::Thrift::Struct_Union
      BOLT_OBJECT = 1
      COMMON = 2

      FIELDS = {
        BOLT_OBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'bolt_object', :class => Storm::ComponentObject},
        COMMON => {:type => ::Thrift::Types::STRUCT, :name => 'common', :class => Storm::ComponentCommon}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field bolt_object is unset!') unless @bolt_object
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field common is unset!') unless @common
      end

      ::Thrift::Struct.generate_accessors self
    end

    class StateSpoutSpec
      include ::Thrift::Struct, ::Thrift::Struct_Union
      STATE_SPOUT_OBJECT = 1
      COMMON = 2

      FIELDS = {
        STATE_SPOUT_OBJECT => {:type => ::Thrift::Types::STRUCT, :name => 'state_spout_object', :class => Storm::ComponentObject},
        COMMON => {:type => ::Thrift::Types::STRUCT, :name => 'common', :class => Storm::ComponentCommon}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field state_spout_object is unset!') unless @state_spout_object
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field common is unset!') unless @common
      end

      ::Thrift::Struct.generate_accessors self
    end

    class StormTopology
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SPOUTS = 1
      BOLTS = 2
      STATE_SPOUTS = 3

      FIELDS = {
        SPOUTS => {:type => ::Thrift::Types::MAP, :name => 'spouts', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => Storm::SpoutSpec}},
        BOLTS => {:type => ::Thrift::Types::MAP, :name => 'bolts', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => Storm::Bolt}},
        STATE_SPOUTS => {:type => ::Thrift::Types::MAP, :name => 'state_spouts', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::STRUCT, :class => Storm::StateSpoutSpec}}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field spouts is unset!') unless @spouts
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field bolts is unset!') unless @bolts
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field state_spouts is unset!') unless @state_spouts
      end

      ::Thrift::Struct.generate_accessors self
    end

    class AlreadyAliveException < ::Thrift::Exception
      include ::Thrift::Struct, ::Thrift::Struct_Union
      def initialize(message=nil)
        super()
        self.msg = message
      end

      def message; msg end

      MSG = 1

      FIELDS = {
        MSG => {:type => ::Thrift::Types::STRING, :name => 'msg'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field msg is unset!') unless @msg
      end

      ::Thrift::Struct.generate_accessors self
    end

    class NotAliveException < ::Thrift::Exception
      include ::Thrift::Struct, ::Thrift::Struct_Union
      def initialize(message=nil)
        super()
        self.msg = message
      end

      def message; msg end

      MSG = 1

      FIELDS = {
        MSG => {:type => ::Thrift::Types::STRING, :name => 'msg'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field msg is unset!') unless @msg
      end

      ::Thrift::Struct.generate_accessors self
    end

    class InvalidTopologyException < ::Thrift::Exception
      include ::Thrift::Struct, ::Thrift::Struct_Union
      def initialize(message=nil)
        super()
        self.msg = message
      end

      def message; msg end

      MSG = 1

      FIELDS = {
        MSG => {:type => ::Thrift::Types::STRING, :name => 'msg'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field msg is unset!') unless @msg
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TopologySummary
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ID = 1
      NAME = 2
      NUM_TASKS = 3
      NUM_EXECUTORS = 4
      NUM_WORKERS = 5
      UPTIME_SECS = 6
      STATUS = 7

      FIELDS = {
        ID => {:type => ::Thrift::Types::STRING, :name => 'id'},
        NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
        NUM_TASKS => {:type => ::Thrift::Types::I32, :name => 'num_tasks'},
        NUM_EXECUTORS => {:type => ::Thrift::Types::I32, :name => 'num_executors'},
        NUM_WORKERS => {:type => ::Thrift::Types::I32, :name => 'num_workers'},
        UPTIME_SECS => {:type => ::Thrift::Types::I32, :name => 'uptime_secs'},
        STATUS => {:type => ::Thrift::Types::STRING, :name => 'status'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_tasks is unset!') unless @num_tasks
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_executors is unset!') unless @num_executors
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_workers is unset!') unless @num_workers
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uptime_secs is unset!') unless @uptime_secs
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
      end

      ::Thrift::Struct.generate_accessors self
    end

    class SupervisorSummary
      include ::Thrift::Struct, ::Thrift::Struct_Union
      HOST = 1
      UPTIME_SECS = 2
      NUM_WORKERS = 3
      NUM_USED_WORKERS = 4
      SUPERVISOR_ID = 5

      FIELDS = {
        HOST => {:type => ::Thrift::Types::STRING, :name => 'host'},
        UPTIME_SECS => {:type => ::Thrift::Types::I32, :name => 'uptime_secs'},
        NUM_WORKERS => {:type => ::Thrift::Types::I32, :name => 'num_workers'},
        NUM_USED_WORKERS => {:type => ::Thrift::Types::I32, :name => 'num_used_workers'},
        SUPERVISOR_ID => {:type => ::Thrift::Types::STRING, :name => 'supervisor_id'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field host is unset!') unless @host
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uptime_secs is unset!') unless @uptime_secs
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_workers is unset!') unless @num_workers
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field num_used_workers is unset!') unless @num_used_workers
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field supervisor_id is unset!') unless @supervisor_id
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ClusterSummary
      include ::Thrift::Struct, ::Thrift::Struct_Union
      SUPERVISORS = 1
      NIMBUS_UPTIME_SECS = 2
      TOPOLOGIES = 3

      FIELDS = {
        SUPERVISORS => {:type => ::Thrift::Types::LIST, :name => 'supervisors', :element => {:type => ::Thrift::Types::STRUCT, :class => Storm::SupervisorSummary}},
        NIMBUS_UPTIME_SECS => {:type => ::Thrift::Types::I32, :name => 'nimbus_uptime_secs'},
        TOPOLOGIES => {:type => ::Thrift::Types::LIST, :name => 'topologies', :element => {:type => ::Thrift::Types::STRUCT, :class => Storm::TopologySummary}}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field supervisors is unset!') unless @supervisors
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field nimbus_uptime_secs is unset!') unless @nimbus_uptime_secs
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field topologies is unset!') unless @topologies
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ErrorInfo
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ERROR = 1
      ERROR_TIME_SECS = 2

      FIELDS = {
        ERROR => {:type => ::Thrift::Types::STRING, :name => 'error'},
        ERROR_TIME_SECS => {:type => ::Thrift::Types::I32, :name => 'error_time_secs'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field error is unset!') unless @error
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field error_time_secs is unset!') unless @error_time_secs
      end

      ::Thrift::Struct.generate_accessors self
    end

    class BoltStats
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ACKED = 1
      FAILED = 2
      PROCESS_MS_AVG = 3
      EXECUTED = 4
      EXECUTE_MS_AVG = 5

      FIELDS = {
        ACKED => {:type => ::Thrift::Types::MAP, :name => 'acked', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRUCT, :class => Storm::GlobalStreamId}, :value => {:type => ::Thrift::Types::I64}}},
        FAILED => {:type => ::Thrift::Types::MAP, :name => 'failed', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRUCT, :class => Storm::GlobalStreamId}, :value => {:type => ::Thrift::Types::I64}}},
        PROCESS_MS_AVG => {:type => ::Thrift::Types::MAP, :name => 'process_ms_avg', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRUCT, :class => Storm::GlobalStreamId}, :value => {:type => ::Thrift::Types::DOUBLE}}},
        EXECUTED => {:type => ::Thrift::Types::MAP, :name => 'executed', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRUCT, :class => Storm::GlobalStreamId}, :value => {:type => ::Thrift::Types::I64}}},
        EXECUTE_MS_AVG => {:type => ::Thrift::Types::MAP, :name => 'execute_ms_avg', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRUCT, :class => Storm::GlobalStreamId}, :value => {:type => ::Thrift::Types::DOUBLE}}}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field acked is unset!') unless @acked
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field failed is unset!') unless @failed
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field process_ms_avg is unset!') unless @process_ms_avg
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field executed is unset!') unless @executed
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field execute_ms_avg is unset!') unless @execute_ms_avg
      end

      ::Thrift::Struct.generate_accessors self
    end

    class SpoutStats
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ACKED = 1
      FAILED = 2
      COMPLETE_MS_AVG = 3

      FIELDS = {
        ACKED => {:type => ::Thrift::Types::MAP, :name => 'acked', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}}},
        FAILED => {:type => ::Thrift::Types::MAP, :name => 'failed', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}}},
        COMPLETE_MS_AVG => {:type => ::Thrift::Types::MAP, :name => 'complete_ms_avg', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::DOUBLE}}}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field acked is unset!') unless @acked
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field failed is unset!') unless @failed
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field complete_ms_avg is unset!') unless @complete_ms_avg
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ExecutorSpecificStats < ::Thrift::Union
      include ::Thrift::Struct_Union
      class << self
        def bolt(val)
          ExecutorSpecificStats.new(:bolt, val)
        end

        def spout(val)
          ExecutorSpecificStats.new(:spout, val)
        end
      end

      BOLT = 1
      SPOUT = 2

      FIELDS = {
        BOLT => {:type => ::Thrift::Types::STRUCT, :name => 'bolt', :class => Storm::BoltStats},
        SPOUT => {:type => ::Thrift::Types::STRUCT, :name => 'spout', :class => Storm::SpoutStats}
      }

      def struct_fields; FIELDS; end

      def validate
        raise(StandardError, 'Union fields are not set.') if get_set_field.nil? || get_value.nil?
      end

      ::Thrift::Union.generate_accessors self
    end

    class ExecutorStats
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EMITTED = 1
      TRANSFERRED = 2
      SPECIFIC = 3

      FIELDS = {
        EMITTED => {:type => ::Thrift::Types::MAP, :name => 'emitted', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}}},
        TRANSFERRED => {:type => ::Thrift::Types::MAP, :name => 'transferred', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::MAP, :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I64}}},
        SPECIFIC => {:type => ::Thrift::Types::STRUCT, :name => 'specific', :class => Storm::ExecutorSpecificStats}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field emitted is unset!') unless @emitted
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field transferred is unset!') unless @transferred
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field specific is unset!') unless @specific
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ExecutorInfo
      include ::Thrift::Struct, ::Thrift::Struct_Union
      TASK_START = 1
      TASK_END = 2

      FIELDS = {
        TASK_START => {:type => ::Thrift::Types::I32, :name => 'task_start'},
        TASK_END => {:type => ::Thrift::Types::I32, :name => 'task_end'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field task_start is unset!') unless @task_start
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field task_end is unset!') unless @task_end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class ExecutorSummary
      include ::Thrift::Struct, ::Thrift::Struct_Union
      EXECUTOR_INFO = 1
      COMPONENT_ID = 2
      HOST = 3
      PORT = 4
      UPTIME_SECS = 5
      STATS = 7

      FIELDS = {
        EXECUTOR_INFO => {:type => ::Thrift::Types::STRUCT, :name => 'executor_info', :class => Storm::ExecutorInfo},
        COMPONENT_ID => {:type => ::Thrift::Types::STRING, :name => 'component_id'},
        HOST => {:type => ::Thrift::Types::STRING, :name => 'host'},
        PORT => {:type => ::Thrift::Types::I32, :name => 'port'},
        UPTIME_SECS => {:type => ::Thrift::Types::I32, :name => 'uptime_secs'},
        STATS => {:type => ::Thrift::Types::STRUCT, :name => 'stats', :class => Storm::ExecutorStats, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field executor_info is unset!') unless @executor_info
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field component_id is unset!') unless @component_id
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field host is unset!') unless @host
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field port is unset!') unless @port
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uptime_secs is unset!') unless @uptime_secs
      end

      ::Thrift::Struct.generate_accessors self
    end

    class TopologyInfo
      include ::Thrift::Struct, ::Thrift::Struct_Union
      ID = 1
      NAME = 2
      UPTIME_SECS = 3
      EXECUTORS = 4
      STATUS = 5
      ERRORS = 6

      FIELDS = {
        ID => {:type => ::Thrift::Types::STRING, :name => 'id'},
        NAME => {:type => ::Thrift::Types::STRING, :name => 'name'},
        UPTIME_SECS => {:type => ::Thrift::Types::I32, :name => 'uptime_secs'},
        EXECUTORS => {:type => ::Thrift::Types::LIST, :name => 'executors', :element => {:type => ::Thrift::Types::STRUCT, :class => Storm::ExecutorSummary}},
        STATUS => {:type => ::Thrift::Types::STRING, :name => 'status'},
        ERRORS => {:type => ::Thrift::Types::MAP, :name => 'errors', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::LIST, :element => {:type => ::Thrift::Types::STRUCT, :class => Storm::ErrorInfo}}}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field id is unset!') unless @id
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field name is unset!') unless @name
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field uptime_secs is unset!') unless @uptime_secs
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field executors is unset!') unless @executors
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field status is unset!') unless @status
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field errors is unset!') unless @errors
      end

      ::Thrift::Struct.generate_accessors self
    end

    class KillOptions
      include ::Thrift::Struct, ::Thrift::Struct_Union
      WAIT_SECS = 1

      FIELDS = {
        WAIT_SECS => {:type => ::Thrift::Types::I32, :name => 'wait_secs', :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class RebalanceOptions
      include ::Thrift::Struct, ::Thrift::Struct_Union
      WAIT_SECS = 1
      NUM_WORKERS = 2
      NUM_EXECUTORS = 3

      FIELDS = {
        WAIT_SECS => {:type => ::Thrift::Types::I32, :name => 'wait_secs', :optional => true},
        NUM_WORKERS => {:type => ::Thrift::Types::I32, :name => 'num_workers', :optional => true},
        NUM_EXECUTORS => {:type => ::Thrift::Types::MAP, :name => 'num_executors', :key => {:type => ::Thrift::Types::STRING}, :value => {:type => ::Thrift::Types::I32}, :optional => true}
      }

      def struct_fields; FIELDS; end

      def validate
      end

      ::Thrift::Struct.generate_accessors self
    end

    class SubmitOptions
      include ::Thrift::Struct, ::Thrift::Struct_Union
      INITIAL_STATUS = 1

      FIELDS = {
        INITIAL_STATUS => {:type => ::Thrift::Types::I32, :name => 'initial_status', :enum_class => Storm::TopologyInitialStatus}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field initial_status is unset!') unless @initial_status
        unless @initial_status.nil? || Storm::TopologyInitialStatus::VALID_VALUES.include?(@initial_status)
          raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Invalid value of field initial_status!')
        end
      end

      ::Thrift::Struct.generate_accessors self
    end

    class DRPCRequest
      include ::Thrift::Struct, ::Thrift::Struct_Union
      FUNC_ARGS = 1
      REQUEST_ID = 2

      FIELDS = {
        FUNC_ARGS => {:type => ::Thrift::Types::STRING, :name => 'func_args'},
        REQUEST_ID => {:type => ::Thrift::Types::STRING, :name => 'request_id'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field func_args is unset!') unless @func_args
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field request_id is unset!') unless @request_id
      end

      ::Thrift::Struct.generate_accessors self
    end

    class DRPCExecutionException < ::Thrift::Exception
      include ::Thrift::Struct, ::Thrift::Struct_Union
      def initialize(message=nil)
        super()
        self.msg = message
      end

      def message; msg end

      MSG = 1

      FIELDS = {
        MSG => {:type => ::Thrift::Types::STRING, :name => 'msg'}
      }

      def struct_fields; FIELDS; end

      def validate
        raise ::Thrift::ProtocolException.new(::Thrift::ProtocolException::UNKNOWN, 'Required field msg is unset!') unless @msg
      end

      ::Thrift::Struct.generate_accessors self
    end

  end
